roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
Lasso = lasso.roc,
Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
#QDA   = qda.roc,
Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
#Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc
#Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
#LogR  = logr.roc, diff
LDA   = lda.roc,
QDA   = qda.roc,
Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
#LogR  = logr.roc,
LDA   = lda.roc,
#QDA   = qda.roc,
Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
#LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
#Lasso = lasso.roc
Ridge = ridge.roc
#KMeans = kmeans.roc,
#HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
roc.mods= list(
#LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
#Lasso = lasso.roc
#Ridge = ridge.roc
#KMeans = kmeans.roc,
HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
# #Hierarchical Clust
## dimension reduction
ds = reduce.data.set(data.set, 1000, seed)
## split data
tts2 = split_df(ds, ratio=split.ratio, seed=seed)
gower.dist = daisy(tts2$train[,-12], metric ="gower")
hc.mod = hclust(gower.dist, method="ward.D2")
groups = cutree(hc.mod, k=2)-1
hc.pred = knn(train=tts2$train[,-12], test=tts2$test[,-12], cl=groups, k=1, prob= T)
# #Hierarchical Clust
## dimension reduction
ds = reduce.data.set(data.set, 35000, seed)
## split data
tts2 = split_df(ds, ratio=split.ratio, seed=seed)
gower.dist = daisy(tts2$train[,-12], metric ="gower")
hc.mod = hclust(gower.dist, method="ward.D2")
groups = cutree(hc.mod, k=2)-1
hc.pred = knn(train=tts2$train[,-12], test=tts2$test[,-12], cl=groups, k=1, prob= T)
hc.pred = attributes(hc.pred)$prob
#kmeans.roc= roc(y.test, kmens.pred, quiet=T)
hc.roc = roc(as.numeric(tts2$test$cardio), hc.pred, quiet=T)
roc.mods= list(
LogR  = logr.roc,
LDA   = lda.roc,
QDA   = qda.roc,
Lasso = lasso.roc,
Ridge = ridge.roc,
#KMeans = kmeans.roc,
HC    = hc.roc
)
theme_set(theme_bw())
ggroc(
roc.mods,
size= 0.8,
legacy.axes= T #normal order axes
) +
# annotate(
#   geom= "text",
#   x= c(0.6, 0.6, 0.6, 0.6, 0.6),
#   y= c(0.75, 0.7, 0.65, 0.6, 0.55),
#   size=2,
#   label= auc.labels,
#   col= cols5,
#   parse= T,
#   hjust= 0
# ) +
labs(
x= "False Positive Ratio",
y= "True Positive Ratio",
col= "Models"
) +
ggtitle("ROC curves and respective AUCs") +
theme(legend.title= element_text(size= 12)) +
scale_x_continuous(labels= scales::percent) +
scale_y_continuous(labels= scales::percent) +
coord_fixed()
## libraries
require(scorecard) # split_df
require(FSA) #headtail
require (glmnet) #lasso
require(caret) #confusion matrix
## seed
seed=123
set.seed(seed)
## split ratio
split.ratio = c(0.7, 0.3)
## functions
accFromCm = function(pred, true) { confusionMatrix(pred, true)$overall[1] }
factorizefeatures = function(dataset){
dataset$gender = as.factor(dataset$gender)
dataset$choles  = as.factor(dataset$choles)
dataset$glucose = as.factor(dataset$glucose)
dataset$smoke = as.factor(dataset$smoke)
dataset$alcohol = as.factor(dataset$alcohol)
dataset$active  = as.factor(dataset$active)
dataset$cardio = as.factor(dataset$cardio)
return(dataset)
}
get.lasso.train.test.error = function(model, best.lambda, x.train, x.test, y.train, y.test, title){
pred.train = predict(model, s=best.lambda, newx=x.train)
pred.train = as.factor(ifelse(pred.train > 0.50, 1, 0))
pred.test = predict(model, s=best.lambda, newx=x.test)
pred.test = as.factor(ifelse(pred.test > 0.50, 1, 0))
return(list(title, accFromCm(pred.train, y.train), accFromCm(pred.test, y.test)))
}
#############################################
## read data - no transformations on the data)
data.set= read.csv("./data/cardio_data.csv")
headtail(data.set)
## factorization
data.set = factorizefeatures(data.set)
## split data
tts = split_df(data.set, ratio=split.ratio, seed=seed)
lasso.y.train.1 = tts$train$cardio
lasso.y.test.1 = tts$test$cardio
###
## complete model
lasso.x.train.1 = model.matrix(cardio~., tts$train)[,-1]
lasso.x.test.1 = model.matrix(cardio~., tts$test)[,-1]
# find best lambda
cv.out.1 = cv.glmnet(lasso.x.train.1, as.numeric(as.character(lasso.y.train.1)), alpha=1)
best.lambda.1 = cv.out.1$lambda.min
# model
lasso.mod.1 = glmnet(lasso.x.train.1, as.numeric(as.character(lasso.y.train.1)), alpha=1)
###
## feature selection - based on EDA of cardio.r
# remove gender, smoke and alcohol
lasso.x.train.2 = model.matrix(cardio~ age  +
height +
weight +
aphi +
aplo +
choles +
glucose +
active, tts$train)[,-1]
lasso.x.test.2 = model.matrix(cardio~ age  +
height +
weight +
aphi +
aplo +
choles +
glucose +
active, tts$test)[,-1]
# find best lambda
cv.out.2 = cv.glmnet(lasso.x.train.2, as.numeric(as.character(lasso.y.train.1)), alpha=1)
best.lambda.2 = cv.out.2$lambda.min
# model
lasso.mod.2 = glmnet(lasso.x.train.2, as.numeric(as.character(lasso.y.train.1)), alpha=1)
###
## train test error
lasso.tt.res = data.frame(0,0,0)
names(lasso.tt.res) = c("method", "train.accuracy", "test.accuracy")
# prediction using the best lambda
lasso.tt.res[1,] = get.lasso.train.test.error(lasso.mod.1,
best.lambda.1,
lasso.x.train.1, lasso.x.test.1,
lasso.y.train.1, lasso.y.test.1,
'with outliers - complete model')
lasso.tt.res[nrow(lasso.tt.res)+1,] = get.lasso.train.test.error(lasso.mod.2,
best.lambda.2,
lasso.x.train.2, lasso.x.test.2,
lasso.y.train.1, lasso.y.test.1,
'with outliers - EDA feature selection')
#############################################
## read data - no height outliers
data.set2= read.csv("./data/data_set_no_height_out.csv")
headtail(data.set2)
data.set2 = factorizefeatures(data.set2)
## split data
tts2 = split_df(data.set2, ratio=split.ratio, seed=seed)
lasso.y.train.2 = tts2$train$cardio
lasso.y.test.2 = tts2$test$cardio
## complete model
lasso.x.train.3 = model.matrix(cardio~., tts2$train)[,-1]
lasso.x.test.3 = model.matrix(cardio~., tts2$test)[,-1]
# find best lambda
cv.out.3 = cv.glmnet(lasso.x.train.3, as.numeric(as.character(lasso.y.train.2)), alpha=1)
best.lambda.3 = cv.out.3$lambda.min
# model
lasso.mod.3 = glmnet(lasso.x.train.3, as.numeric(as.character(lasso.y.train.2)), alpha=1)
## feature selection - based on EDA of cardio.r
# remove gender, smoke and alcohol
lasso.x.train.4 = model.matrix(cardio~ age  +
height +
weight +
aphi +
aplo +
choles +
glucose +
active, tts2$train)[,-1]
lasso.x.test.4 = model.matrix(cardio~ age  +
height +
weight +
aphi +
aplo +
choles +
glucose +
active, tts2$test)[,-1]
#find best lambda
cv.out.4 = cv.glmnet(lasso.x.train.4, as.numeric(as.character(lasso.y.train.2)), alpha=1)
best.lambda.4 = cv.out.4$lambda.min
#model
lasso.mod.4 = glmnet(lasso.x.train.4, as.numeric(as.character(lasso.y.train.2)), alpha=1)
### train test error
#prediction using the best lambda
lasso.tt.res[nrow(lasso.tt.res)+1,] = get.lasso.train.test.error(lasso.mod.3,
best.lambda.3,
lasso.x.train.3, lasso.x.test.3,
lasso.y.train.2, lasso.y.test.2,
'without outliers - complete model')
lasso.tt.res[nrow(lasso.tt.res)+1,] = get.lasso.train.test.error(lasso.mod.4,
best.lambda.4,
lasso.x.train.4, lasso.x.test.4,
lasso.y.train.2, lasso.y.test.2,
'without outliers - EDA feature selection')
lasso.tt.res
# method train.accuracy test.accuracy
